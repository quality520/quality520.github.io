<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>title:RegExp类型</title>
</head>
<body>
 {{page.title}}
</h2><p data-anchor-id="j47y"> 
{{page.date | date_to_string}}

</p><blockquote data-anchor-id="338z"class="white-blockquote">
<p>ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式    </p>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="8bq9"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> expression </span><span class="pun">=</span><span class="pln"> </span><span class="str">/ pattern /</span><span class="pln"> flags</span><span class="pun">;
</span></code></li></ol></pre><blockquote data-anchor-id="73ob"class="white-blockquote">
<p>模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含 <code>字符类、限定类、分组、向前查找以及反向引用</code>  <br>
每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。以下为三个标志 <br>
* g: 表示全局(global)模式，即模式将应用于所有字符串，而非在发现第一个匹配项时立即停止 <br>
* i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写； <br>
* m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项    </p>
</blockquote><div class="md-section-divider"></div><h4 data-anchor-id="9zkt"id="example">Example</h4><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="95hc"><ol class="linenums"><li class="L0"><code><span class="com">/*</span></code></li><li class="L1"><code><span class="com">*匹配字符串中所有"at"的实例</span></code></li><li class="L2"><code><span class="com">*/</span></code></li><li class="L3"><code><span class="kwd">var</span><span class="pln"> pattern1 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/at/</span><span class="pln">g</span><span class="pun">;
</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="com">/*</span></code></li><li class="L6"><code><span class="com">*匹配第一个"bat"或"cat",不区分大小写</span></code></li><li class="L7"><code><span class="com">*/</span></code></li><li class="L8"><code><span class="kwd">var</span><span class="pln"> pattern2 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/[bc]at/</span><span class="pun">;
</span></code></li><li class="L9"><code></code></li><li class="L0"><code><span class="com">/*</span></code></li><li class="L1"><code><span class="com">* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写</span></code></li><li class="L2"><code><span class="com">*/</span></code></li><li class="L3"><code><span class="kwd">var</span><span class="pln"> pattern3 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/.at/</span><span class="pln">g</span><span class="pun">;

</span></code></li></ol></pre><blockquote data-anchor-id="s01k"class="white-blockquote">
<p>正则比到达时模式中使用的所有元字符都必须转义。元字符包括： <br>
<code>([ {
  \ ^ $ | ? * + .
}

])</code></p>
</blockquote><div class="md-section-divider"></div><h4 data-anchor-id="43jr"id="example-1">Example</h4><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="wxwv"><ol class="linenums"><li class="L0"><code><span class="com">/*</span></code></li><li class="L1"><code><span class="com">* 匹配第一个"bat"或"cat"，不区分大小写</span></code></li><li class="L2"><code><span class="com">*/</span></code></li><li class="L3"><code><span class="kwd">var</span><span class="pln"> pattern1  </span><span class="pun">=</span><span class="pln"> </span><span class="str">/[bc]at/</span><span class="pun">;
</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="com">/*</span></code></li><li class="L6"><code><span class="com">* 匹配第一个" [bc]at"，不区分大小写</span></code></li><li class="L7"><code><span class="com">*/</span></code></li><li class="L8"><code><span class="kwd">var</span><span class="pln"> pattern2 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/\[bc\]at/</span><span class="pun">;
</span></code></li><li class="L9"><code></code></li><li class="L0"><code><span class="com">/*</span></code></li><li class="L1"><code><span class="com">* 匹配所有以"at"结尾的 3 个字符的组合，不区分大小写</span></code></li><li class="L2"><code><span class="com">*/</span></code></li><li class="L3"><code><span class="kwd">var</span><span class="pln"> pattern3 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/.at/</span><span class="pln">gi</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="com">/*</span></code></li><li class="L6"><code><span class="com">* 匹配所有".at"，不区分大小写</span></code></li><li class="L7"><code><span class="com">*/</span></code></li><li class="L8"><code><span class="kwd">var</span><span class="pln"> pattern4 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/\.at/</span><span class="pln">gi</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="xsmv"id="regexp构造函数">RegExp构造函数</h4><blockquote data-anchor-id="xh6a"class="white-blockquote">
<p>前面的例子都是通过字面量形式来定义正则表达式。 <br>
另外一种创建正则表达式的方式是使用RegExp构造函数，它接受两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。</p>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="a2cv"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> pattern1 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/[bc]at/</span><span class="pln">i</span><span class="pun">;
</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="kwd">var</span><span class="pln"> pattern2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RegExp</span><span class="pun">(</span><span class="str">"[bc]at"</span><span class="pun">, </span><span class="str">"i"</span><span class="pun">);

</span></code></li><li class="L3"><code><span class="com">/*pattern1与pattern2是两个完全等价的正则表达式*/</span></code></li></ol></pre><div class="md-section-divider"></div><h5 data-anchor-id="l6rb"id="tips">tips</h5><blockquote data-anchor-id="bsb1"class="white-blockquote">
<p>传递给RegExp构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp构造函数）。由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。</p>
</blockquote><table data-anchor-id="5udk"class="table table-striped-white table-bordered">
<thead>
<tr>
<th style="text-align:center;">字面量模式</th>
<th style="text-align:center;">等价的字符串</th>
</tr>
</thead>
<tbody><tr>
<td style="text-align:center;">/[bc]at/</td>
<td style="text-align:center;">"<span class="MathJax_Preview"></span><div class="MathJax_SVG_Display"role="textbox"aria-readonly="true"style="text-align: center;"><span class="MathJax_SVG"id="MathJax-Element-3-Frame"style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink"viewBox="0 -715.0516853480245 863 748.103370696049"style="width: 1.969ex; height: 1.737ex; vertical-align: -0.116ex; margin: 1px 0px;"><g stroke="black"fill="black"stroke-width="0"transform="matrix(1 0 0 -1 0 0)"><use xmlns:xlink="http://www.w3.org/1999/xlink"xlink:href="#MJMATHI-62"></use><use xmlns:xlink="http://www.w3.org/1999/xlink"xlink:href="#MJMATHI-63"x="429"y="0"></use></g></svg></span></div><script type="math/tex; mode=display"id="MathJax-Element-3">bc</script>at"</td>
</tr>
<tr>
<td style="text-align:center;">/.at/</td>
<td style="text-align:center;">"\.at"</td>
</tr>
<tr>
<td style="text-align:center;">/name\/age/</td>
<td style="text-align:center;">"name\age"</td>
</tr>
<tr>
<td style="text-align:center;">/\d.\d {
  1, 2
}

/</td>
<td style="text-align:center;">"\d.\d {
  1, 2
}

"</td>
</tr>
<tr>
<td style="text-align:center;">/\w\hello\123/</td>
<td style="text-align:center;">"\w\\hello\\123"</td>
</tr>
</tbody></table><blockquote data-anchor-id="uzrs"class="white-blockquote">
<p>使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript3中，正则表达式字面量始终共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例</p>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="0xvj"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> re </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">, </span><span class="pln">i</span><span class="pun">;
</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="kwd">for</span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;
</span><span class="pln">i </span><span class="pun">&lt;
</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;

</span><span class="pln">i</span><span class="pun">++) {
  </span></code></li><li class="L3"><code><span class="pln">  re </span><span class="pun">=</span><span class="pln"> </span><span class="str">/cat/</span><span class="pln">g</span><span class="pun">;
  </span></code></li><li class="L4"><code><span class="pln"> re</span><span class="pun">.</span><span class="pln">test</span><span class="pun">(</span><span class="str">'catastrophe'</span><span class="pun">)</span></code></li><li class="L5"><code><span class="pun">
}

</span></code></li><li class="L6"><code></code></li><li class="L7"><code><span class="kwd">for</span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;
</span><span class="pln">i </span><span class="pun">&lt;
</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;

</span><span class="pln">i</span><span class="pun">++) {
  </span></code></li><li class="L8"><code><span class="pln">  re </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RegExp</span><span class="pun">(</span><span class="str">'cat'</span><span class="pun">, </span><span class="str">'g'</span><span class="pun">);
  </span></code></li><li class="L9"><code><span class="pln">  re</span><span class="pun">.</span><span class="pln">test</span><span class="pun">(</span><span class="str">'catastrophe'</span><span class="pun">);
  </span></code></li><li class="L0"><code><span class="pun">
}

</span></code></li></ol></pre><blockquote data-anchor-id="rmx5"class="white-blockquote">
<p>在第一个循环中，即使是循环体中指定的，但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用 test() 方法会失败。这是因为第一次调用 test() 找到了 "cat" ，但第二次调用是从索引为 3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用 test() 就又从开头开始了。 <br>
第二个循环使用 RegExp 构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp 实例，所以每次调用 test() 都会返回 true 。 <br>
<strong><em>ECMAScript5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例</em></strong></p>
</blockquote><div class="md-section-divider"></div><h4 data-anchor-id="tex9"id="regexp实例属性">RegExp实例属性</h4><blockquote data-anchor-id="0n4y"class="white-blockquote">
<p>RegExp的每个实例都具有下列属性，通过这些属性可以获取有关模式的各种信息： <br>
* global：布尔值，表示是否设置了g标志 <br>
* ignoreCase：布尔值，表示是否设置了i标志 <br>
* lastIndex：整数，表示开始搜索下一个匹配项的字符位置。从0算起 <br>
* multiline：布尔值，表示是否设置了m标志 <br>
* source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 <br>
<strong><em>通过这些属性可以获知一个正则表达式的各方面信息，单却没有多大用处，因为这些信息全部包含在模式声明中</em></strong></p>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="xckt"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> pattern1 </span><span class="pun">=</span><span class="pln"> </span><span class="str">/\[bc\]at/</span><span class="pln">i</span><span class="pun">;
</span></code></li><li class="L1"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern1</span><span class="pun">.</span><span class="kwd">global</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//false</span></code></li><li class="L2"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern1</span><span class="pun">.</span><span class="pln">ignoreCase</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//true</span></code></li><li class="L3"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern1</span><span class="pun">.</span><span class="pln">multiline</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//false</span></code></li><li class="L4"><code><span class="pln">conosle</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern1</span><span class="pun">.</span><span class="pln">lastIndex</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//0;
</span></code></li><li class="L5"><code><span class="pln">conosle</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern1</span><span class="pun">.</span><span class="pln">source</span><span class="pun">);
</span><span class="pln"> </span><span class="pun">/</span><span class="str">"\[bc\]at"</span><span class="pun">/</span></code></li><li class="L6"><code></code></li><li class="L7"><code><span class="kwd">var</span><span class="pln"> pattern2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RegExp</span><span class="pun">(</span><span class="str">'\[bc\]at'</span><span class="pun">, </span><span class="str">'i'</span><span class="pun">);
</span></code></li><li class="L8"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern2</span><span class="pun">.</span><span class="kwd">global</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//false</span></code></li><li class="L9"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern2</span><span class="pun">.</span><span class="pln">ignoreCase</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//true</span></code></li><li class="L0"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern2</span><span class="pun">.</span><span class="pln">multiline</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//false</span></code></li><li class="L1"><code><span class="pln">conosle</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern2</span><span class="pun">.</span><span class="pln">lastIndex</span><span class="pun">);
</span><span class="pln"> </span><span class="com">//0;
</span></code></li><li class="L2"><code><span class="pln">conosle</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern2</span><span class="pun">.</span><span class="pln">source</span><span class="pun">);
</span><span class="pln"> </span><span class="pun">/</span><span class="str">"\[bc\]at"</span><span class="pun">/</span></code></li></ol></pre><blockquote data-anchor-id="f05m"class="white-blockquote">
<p>上述代码中第一个模式使用的是字面量，第二个模式使用了RegExp构造函数，但他们的source属性是相同的，可见，source属性保存的是规范形式的字符串，即字面量形式使用的字符串。</p>
</blockquote><div class="md-section-divider"></div><h4 data-anchor-id="w7xm"id="regexp实例方法">RegExp实例方法</h4><div class="md-section-divider"></div><h5 data-anchor-id="iczv"id="exec方法">exec方法</h5><blockquote data-anchor-id="p1c7"class="white-blockquote">
<p>exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配想的情况下返回null。返回的数组虽然是Array的实例，单包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</p>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="r0av"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> text </span><span class="pun">=</span><span class="pln"> </span><span class="str">'mom and dad and baby'</span><span class="pun">;
</span></code></li><li class="L1"><code><span class="kwd">var</span><span class="pln"> pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">/mom(and dad(and baby)?)?/</span><span class="pln">gi</span><span class="pun">;
</span></code></li><li class="L2"><code><span class="kwd">var</span><span class="pln"> matches </span><span class="pun">=</span><span class="pln"> pattern</span><span class="pun">.</span><span class="kwd">exec</span><span class="pun">(</span><span class="pln">text</span><span class="pun">);
</span></code></li><li class="L3"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">matches</span><span class="pun">);
</span></code></li><li class="L4"><code><span class="com">//[</span></code></li><li class="L5"><code><span class="pln">    </span><span class="str">"mom and dad and baby"</span><span class="pun">, </span><span class="pln"> </span></code></li><li class="L6"><code><span class="pln">    </span><span class="str">" and dad and baby"</span><span class="pun">, </span><span class="pln"> </span></code></li><li class="L7"><code><span class="pln">    </span><span class="str">" and baby"</span><span class="pun">, </span><span class="pln"> </span></code></li><li class="L8"><code><span class="pln">    index</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">, </span><span class="pln"> </span></code></li><li class="L9"><code><span class="pln">    input</span><span class="pun">:</span><span class="pln"> </span><span class="str">"mom and dad and baby"</span></code></li><li class="L0"><code><span class="pun">]</span></code></li></ol></pre><div class="md-section-divider"></div><h5 data-anchor-id="8lz9"id="test方法">test方法</h5><blockquote data-anchor-id="183l"class="white-blockquote">
<p>test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法比较方便。</p>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="a6pd"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> text </span><span class="pun">=</span><span class="pln"> </span><span class="str">'000-00-0000'</span><span class="pun">;

</span></code></li><li class="L1"><code><span class="kwd">var</span><span class="pln"> pattern </span><span class="pun">=</span><span class="pln"> </span><span class="str">/\d {
  3
}

-\d {
  2
}

-\d {
  4
}

/</span><span class="pun">;

</span></code></li><li class="L2"><code><span class="kwd">if</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">.</span><span class="pln">test</span><span class="pun">(</span><span class="pln">text</span><span class="pun">)) {
  </span></code></li><li class="L3"><code><span class="pln">    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'The pattern was matched'</span><span class="pun">);
  </span></code></li><li class="L4"><code><span class="pun">
}

</span></code></li></ol></pre><div class="md-section-divider"></div><h5 data-anchor-id="94bh"id="tolocalestring-tostring方法">toLocaleString 、toString方法</h5><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted"data-anchor-id="638n"><ol class="linenums"><li class="L0"><code><span class="kwd">var</span><span class="pln"> pattern </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RegExp</span><span class="pun">(</span><span class="str">'\\[bc\\]at'</span><span class="pun">, </span><span class="str">'gi'</span><span class="pun">);
</span></code></li><li class="L1"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">.</span><span class="pln">toLocaleString</span><span class="pun">());
</span></code></li><li class="L2"><code><span class="com">// /\[bc\]/gi</span></code></li><li class="L3"><code><span class="pln">console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">pattern</span><span class="pun">.</span><span class="pln">toLocaleString</span><span class="pun">();
</span></code></li><li class="L4"><code><span class="com">// /\[bc\]/gi</span></code></li></ol></pre><blockquote data-anchor-id="jo19"class="white-blockquote">
<p>即使上例中的模式是通过调用RegExp构造函数创建的，但toLocaleString()和toString()方法仍然会像它是以字面量形式创建的一样显示字符串表示 <br>
<em>tips:正则表达式的valueOf()方法返回正则表达式本身</em></p>
</blockquote><div class="md-section-divider"></div><h4 data-anchor-id="crxb"id="regexp构造函数属性">RegExp构造函数属性</h4><blockquote data-anchor-id="x1qa"class="white-blockquote">
<p>RegExp构造函数包含一些属性，这些属性适用于作用域中</p>
</blockquote></div>
</body>
</html>